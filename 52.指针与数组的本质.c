/*指针与数组的本质*/
#include <stdio.h>

int add(int *arr);

int main(){
    
    int arr[3]={1,2,3};
    int *p=arr;//等效于:int *p=&arr[0];
    printf("%d\n",*(arr+2));
    
    //假设数组就是指针.那么指针的所有特性数组也具备.
    double d1=0.1;
    double *d=&d1;
    char c1='a';
    char *c=&c1;
    
    //指针的长度都是一样的.只要在同一编译环境下.那么如果数组是指针,那数组的长度也应该和指针一样.
    printf("p=%lu---d=%lu---c=%lu---arr=%lu\n",sizeof(p),sizeof(d),sizeof(c),sizeof(arr));
    
    //但是,实际数组长度并不和指针一样.是动态变化的,根据当前类型及数组长度.
    //假设不成立.
    //结论:数组不是指针.
    
    /*
     
     数组与指针的异同点
     
     相同点:
        1.二者都含有一个地址.
        2.二者都能通过*变量名取值
        3.二者都能通过变量名[角标]去取值.
        4.二者都可以进行地址运算.
     
     不同点:
        1.二者是不同类型.数组:是构造类型 指针:指针类型
        2.数组的字节长度是动态的,与类型和长度有关.而指针字节数是一致的(同一环境)
        3.数组用变量名[角标]取值时越界会有警告.而指针没有.
        4.数组用变量名[角标]取值时角标是谁的,就是哪个元素.但是指针是用当前地址对应的角标+当前给定的角标.
        5.数组里面的地址不可以改变,而指针可以.
     
     */
    
    //arr=arr+1;出错
    p=p+1;
    add(arr);
    
    //*结论:数组具有指针的一部特性,但是它不是指针.二者是完全不同的两个数据类型
    
    //如果数组当参数传递时,或赋值时,仅把里面的第一个元素的地址传过去了.
    
    p=arr;//&arr[0];
    return 0;
    
}

int add(int *arr){
    return 0;
}


